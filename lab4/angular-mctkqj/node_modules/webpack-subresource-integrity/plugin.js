"use strict";
/**
 * Copyright (c) 2015-present, Waysact Pty Ltd
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plugin = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const assert = __importStar(require("typed-assert"));
const util_1 = require("./util");
const assetTypeIntegrityKeys = [
    ["js", "jsIntegrity"],
    ["css", "cssIntegrity"],
];
class Plugin {
    constructor(compilation, options, reporter) {
        /**
         * @internal
         */
        this.assetIntegrity = new Map();
        /**
         * @internal
         */
        this.inverseAssetIntegrity = new Map();
        /**
         * @internal
         */
        this.hwpPublicPath = null;
        /**
         * @internal
         */
        this.sortedSccChunks = [];
        /**
         * @internal
         */
        this.chunkManifest = new Map();
        /**
         * @internal
         */
        this.hashByChunkId = new Map();
        /**
         * @internal
         */
        this.addMissingIntegrityHashes = (assets) => {
            Object.keys(assets).forEach((assetKey) => {
                const asset = assets[assetKey];
                let source;
                try {
                    source = asset.source();
                }
                catch (_) {
                    return;
                }
                this.updateAssetIntegrity(assetKey, util_1.computeIntegrity(this.options.hashFuncNames, source));
            });
        };
        /**
         * @internal
         */
        this.replaceAsset = (compiler, assets, hashByChunkId, chunkFile) => {
            const oldSource = assets[chunkFile].source();
            const hashFuncNames = this.options.hashFuncNames;
            const newAsset = new compiler.webpack.sources.ReplaceSource(assets[chunkFile], chunkFile);
            Array.from(hashByChunkId.entries()).forEach((idAndHash) => {
                const magicMarker = util_1.makePlaceholder(hashFuncNames, idAndHash[0]);
                const magicMarkerPos = oldSource.indexOf(magicMarker);
                if (magicMarkerPos >= 0) {
                    newAsset.replace(magicMarkerPos, magicMarkerPos + magicMarker.length - 1, idAndHash[1], chunkFile);
                }
            });
            assets[chunkFile] = newAsset;
            return newAsset;
        };
        this.warnAboutLongTermCaching = (assetInfo) => {
            if ((assetInfo.fullhash ||
                assetInfo.chunkhash ||
                assetInfo.modulehash ||
                assetInfo.contenthash) &&
                !(assetInfo.contenthash &&
                    this.compilation.compiler.options.optimization.realContentHash)) {
                this.reporter.warnOnce("Using [hash], [fullhash], [modulehash], or [chunkhash] is dangerous \
with SRI. The same is true for [contenthash] when realContentHash is disabled. \
Use [contenthash] and ensure realContentHash is enabled. See the README for \
more information.");
            }
        };
        /**
         * @internal
         */
        this.processChunk = (chunk, assets) => {
            Array.from(util_1.findChunks(chunk))
                .reverse()
                .forEach((chunk) => this.processChunkAssets(chunk, assets));
        };
        this.processChunkAssets = (childChunk, assets) => {
            const files = Array.from(childChunk.files);
            files.forEach((sourcePath) => {
                if (assets[sourcePath]) {
                    this.warnIfHotUpdate(assets[sourcePath].source());
                    const newAsset = this.replaceAsset(this.compilation.compiler, assets, this.hashByChunkId, sourcePath);
                    const integrity = util_1.computeIntegrity(this.options.hashFuncNames, newAsset.source());
                    if (childChunk.id !== null) {
                        this.hashByChunkId.set(childChunk.id, integrity);
                    }
                    this.updateAssetIntegrity(sourcePath, integrity);
                    this.compilation.updateAsset(sourcePath, (x) => x, (assetInfo) => {
                        if (!assetInfo) {
                            return undefined;
                        }
                        this.warnAboutLongTermCaching(assetInfo);
                        return {
                            ...assetInfo,
                            contenthash: Array.isArray(assetInfo.contenthash)
                                ? [...new Set([...assetInfo.contenthash, integrity])]
                                : assetInfo.contenthash
                                    ? [assetInfo.contenthash, integrity]
                                    : integrity,
                        };
                    });
                }
                else {
                    this.reporter.warnOnce(`No asset found for source path '${sourcePath}', options are ${Object.keys(assets).join(", ")}`);
                }
            });
        };
        /**
         * @internal
         */
        this.addAttribute = (elName, source) => {
            if (!this.compilation.outputOptions.crossOriginLoading) {
                this.reporter.errorOnce("webpack option output.crossOriginLoading not set, code splitting will not work!");
            }
            return this.compilation.compiler.webpack.Template.asString([
                source,
                elName + `.integrity = ${util_1.sriHashVariableReference}[chunkId];`,
                elName +
                    ".crossOrigin = " +
                    JSON.stringify(this.compilation.outputOptions.crossOriginLoading) +
                    ";",
            ]);
        };
        /**
         * @internal
         */
        this.processAssets = (assets) => {
            if (this.options.hashLoading === "lazy") {
                for (const scc of this.sortedSccChunks) {
                    for (const chunk of scc.nodes) {
                        this.processChunkAssets(chunk, assets);
                    }
                }
            }
            else {
                Array.from(this.compilation.chunks)
                    .filter((chunk) => chunk.hasRuntime())
                    .forEach((chunk) => {
                    this.processChunk(chunk, assets);
                });
            }
            this.addMissingIntegrityHashes(assets);
        };
        /**
         * @internal
         */
        this.hwpAssetPath = (src) => {
            assert.isNotNull(this.hwpPublicPath);
            return path_1.relative(this.hwpPublicPath, src);
        };
        /**
         * @internal
         */
        this.getIntegrityChecksumForAsset = (assets, src) => {
            if (this.asset